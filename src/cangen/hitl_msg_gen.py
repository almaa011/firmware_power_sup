import can_parser
import sys
import os
import yaml

# you need to pass in the path to the firmware repo
firmware_repo_path = sys.argv[1]


def build_class_name(packet_name):
    parts = packet_name.split("_")
    return "".join([p.title() for p in parts])


def build_getter_setter(field):
    name = field["name"]
    _type = field["type"]
    byte = field["byte"]

    lookup = {
        "uint8_t": "uint8",
        "int8_t": "int8",
        "uint16_t": "uint16",
        "int16_t": "int16",
        "uint32_t": "uint32",
        "int32_t": "int32",
        "uint64_t": "uint64",
        "int64_t": "int64",
        "float": "float",
    }

    if _type == "bitfield":
        bit = field["bit"]
        getter = f"_get_bitfield(byte={byte}, pos={bit})"
        setter = f"_set_bitfield(byte={byte}, pos={bit}, value=value)"
    elif _type in lookup:
        getter = f"_get_{lookup[_type]}(byte={byte})"
        setter = f"_set_{lookup[_type]}(byte={byte}, value=value)"
    else:
        print("WARNING: custom enum types are not supported yet!")

    return f"""
    @property
    def {name}(self):
        return self.{getter}

    @{name}.setter
    def {name}(self, value):
        self.{setter}
"""


for file_name in os.listdir("packets/"):
    if file_name.endswith(".ignore.yaml") or not file_name.endswith(".yaml"):
        continue
    print(file_name)
    with open(os.path.join("packets", file_name), "r", encoding="utf-8") as f:
        yaml_file = yaml.safe_load(f)
        packets = yaml_file["packets"]

    classes = []
    for packet in packets:
        if "repeat" in packet:
            print("WARNING: repeat not supported yet!")
        if type(packet["name"]) == list:
            print("WARNING: list of packet names not supported yet!")
            continue
        class_name = build_class_name(packet["name"])
        _id = hex(packet["id"])

        fields = []

        bytenum = 0
        for field in packet["data"]:
            if field["type"] == "bitfield":
                bitcount = 0
                for subfield in field["bits"]:
                    if "bitnum" not in subfield:
                        subfield["bitnum"] = 1
                    fields.append(
                        {
                            "name": subfield["name"],
                            "type": "bitfield",
                            "byte": bytenum,
                            "bit": bitcount,
                        }
                    )
                    bitcount += 1
                bytenum += 1
            else:
                fields.append(
                    {"name": field["name"], "type": field["type"], "byte": bytenum}
                )
                bytenum += can_parser.c_lengths[field["type"]]

        msg_class = f"""
class {class_name}(AbstractMessage):

    can_id = {_id}
    length = {bytenum}
    period = {0.0}  # TODO: not implemented yet!
"""

        for field in fields:
            msg_class += build_getter_setter(field)

        classes.append(msg_class)

    out = """
# This file is generated by hitl_msg_gen.py

from messages.abstract_message import AbstractMessage

import can  # pip install python-can    
"""

    out += "\n".join(classes)

    out_file_name = file_name[: -len(".yaml")] + ".py"
    with open(
        os.path.join(
            firmware_repo_path, "tools", "hitl_testing", "messages", out_file_name
        ),
        "w",
    ) as f:
        f.write(out)
